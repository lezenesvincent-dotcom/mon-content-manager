<!-- 
========================================
Graphique 3D Boursier - VERSION ORANGE (VORANGE)
Version: 15.45 - 13 novembre 2025
Description: Version avec d√©grad√© orange/rouge et graphique orange/jaune
========================================
-->
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphique 3D Boursier - VERSION ORANGE (VORANGE)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%); /* D√©grad√© orange/rouge */
            overflow: hidden;
            width: 1920px;
            height: 1080px;
        }

        #container {
            width: 1920px;
            height: 1080px;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* STATS COMPACTES EN HAUT (15% de hauteur) */
        #stats {
            height: 15%;
            padding: 20px 40px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 60px;
            background: rgba(0, 0, 0, 0.2);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .stat-label {
            font-size: 28px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: normal;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 56px;
            color: white;
            font-weight: bold;
        }

        .stat-value.positive {
            color: #4ade80;
        }

        /* GRAPHIQUE OCCUPE 85% */
        #chartContainer {
            height: 85%;
            position: relative;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
            /* Ombre incurv√©e style Apple Keynote */
            filter: drop-shadow(0 15px 40px rgba(0, 0, 0, 0.5));
        }

        /* Effet d'ombre incurv√©e sous le canvas */
        #chartContainer::after {
            content: '';
            position: absolute;
            bottom: 5%;
            left: 10%;
            right: 10%;
            height: 60px;
            background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.4) 0%, transparent 70%);
            filter: blur(20px);
            z-index: -1;
            border-radius: 50%;
            transform: scaleY(0.3); /* Aplatir pour effet incurv√© */
        }

        #refreshButton {
            position: absolute;
            bottom: 30px;
            right: 30px;
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 100;
        }

        #refreshButton:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        #applyButton {
            position: absolute;
            top: 30px;  /* En haut √† droite */
            right: 30px;
            padding: 15px 30px;
            background: rgba(100, 255, 100, 0.3);
            border: 2px solid #4ade80;
            color: white;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 1000;  /* Z-index √©lev√© pour √™tre au-dessus de tout */
        }

        #applyButton:hover {
            background: rgba(100, 255, 100, 0.5);
            transform: scale(1.05);
        }

        #applyButton.saved {
            background: rgba(100, 255, 100, 0.8);
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #yearLabels {
            position: absolute;
            left: 40px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .year-label {
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
        }

        #priceLabels {
            position: absolute;
            left: 40px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
        }

        .price-label {
            color: white;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
        }

        /* CONTR√îLEURS */
        #controllers {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 30px;
            z-index: 1000;
        }

        .controller {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 12px;  /* R√©duit de 20px √† 12px */
            color: white;
            backdrop-filter: blur(10px);
        }

        .controller h3 {
            margin: 0 0 10px 0;  /* R√©duit de 15px √† 10px */
            font-size: 14px;  /* R√©duit de 18px √† 14px */
            text-align: center;
        }

        .joystick-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .joystick-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .joystick-btn {
            width: 40px;   /* R√©duit de 50px √† 40px */
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            border-radius: 8px;
            color: white;
            font-size: 16px;  /* R√©duit de 20px √† 16px */
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .joystick-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }

        .joystick-btn:active {
            transform: scale(0.95);
        }

        .reset-btn {
            margin-top: 10px;
            width: 100%;
            padding: 10px;
            background: rgba(255, 100, 100, 0.8);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }

        .reset-btn:hover {
            background: rgba(255, 100, 100, 1);
        }

        .info-display {
            margin-top: 10px;
            font-size: 12px;
            text-align: center;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- STATS COMPACTES -->
        <div id="stats"></div>
        
        <!-- GRAPHIQUE GRAND -->
        <div id="chartContainer">
            <canvas id="threeCanvas"></canvas>
            <div id="yearLabels"></div>
            <button id="applyButton" onclick="applySettings()">‚úì Appliquer</button>
            <button id="refreshButton" onclick="reloadAnimation()">üîÑ Rafra√Æchir</button>
        </div>

        <!-- CONTR√îLEURS -->
        <div id="controllers">
            <!-- Contr√¥leur Cam√©ra Position -->
            <div class="controller">
                <h3>üìπ Position Cam√©ra</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveCamera('up')">‚Üë</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveCamera('left')">‚Üê</button>
                        <button class="joystick-btn" onclick="moveCamera('center')">‚óè</button>
                        <button class="joystick-btn" onclick="moveCamera('right')">‚Üí</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveCamera('down')">‚Üì</button>
                    </div>
                    <button class="reset-btn" onclick="resetCamera()">Reset Position</button>
                    <div class="info-display" id="cameraInfo">X:0 Y:5 Z:32</div>
                </div>
            </div>

            <!-- Contr√¥leur Angle Cam√©ra -->
            <div class="controller">
                <h3>üéØ Angle Cam√©ra</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="rotateCamera('up')" title="Plong√©e (regarder vers le bas)">‚ñ≤</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="rotateCamera('left')" title="Tourner √† gauche">‚óÄ</button>
                        <button class="joystick-btn" onclick="rotateCamera('center')">‚óè</button>
                        <button class="joystick-btn" onclick="rotateCamera('right')" title="Tourner √† droite">‚ñ∂</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="rotateCamera('down')" title="Contre-plong√©e (regarder vers le haut)">‚ñº</button>
                    </div>
                    <button class="reset-btn" onclick="resetCameraAngle()">Reset Angle</button>
                    <div class="info-display" id="angleInfo">H:0¬∞ V:-20¬∞</div>
                </div>
            </div>

            <!-- Contr√¥leur Graphique -->
            <div class="controller">
                <h3>üìä Graphique XY</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveGraph('up')">‚Üë</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveGraph('left')">‚Üê</button>
                        <button class="joystick-btn" onclick="moveGraph('center')">‚óè</button>
                        <button class="joystick-btn" onclick="moveGraph('right')">‚Üí</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveGraph('down')">‚Üì</button>
                    </div>
                    <button class="reset-btn" onclick="resetGraph()">Reset</button>
                    <div class="info-display" id="graphInfo">X:0 Y:0 Z:0</div>
                </div>
            </div>

            <!-- Contr√¥leur Profondeur Graphique (Z) -->
            <div class="controller">
                <h3>üìä Profondeur (Z)</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveGraph('forward')" title="Rapprocher">‚¨ÜÔ∏è</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveGraph('center')">‚óè</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveGraph('backward')" title="√âloigner">‚¨áÔ∏è</button>
                    </div>
                    <button class="reset-btn" onclick="resetGraph()">Reset</button>
                    <div class="info-display" id="graphZInfo">Z:0</div>
                </div>
            </div>

            <!-- Contr√¥leur Lumi√®re Position -->
            <div class="controller">
                <h3>üí° Position Lumi√®re</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLight('up')">‚Üë</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLight('left')">‚Üê</button>
                        <button class="joystick-btn" onclick="moveLight('center')">‚óè</button>
                        <button class="joystick-btn" onclick="moveLight('right')">‚Üí</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLight('down')">‚Üì</button>
                    </div>
                    <button class="reset-btn" onclick="resetLight()">Reset</button>
                    <div class="info-display" id="lightInfo">X:5 Y:10 Z:7</div>
                </div>
            </div>

            <!-- Contr√¥leur Intensit√© Lumi√®re -->
            <div class="controller">
                <h3>üîÜ Intensit√©</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="adjustIntensity('up')" style="font-size: 24px;">‚òÄÔ∏è</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="adjustIntensity('center')" style="font-size: 18px;">‚óè</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="adjustIntensity('down')" style="font-size: 24px;">üåô</button>
                    </div>
                    <button class="reset-btn" onclick="resetLight()">Reset</button>
                    <div class="info-display" id="intensityInfo">60%</div>
                </div>
            </div>

            <!-- Contr√¥leur Profondeur Lumi√®re (Z) -->
            <div class="controller">
                <h3>üí° Profondeur (Z)</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLight('forward')" title="Rapprocher">‚¨ÜÔ∏è</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLight('center')">‚óè</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLight('backward')" title="√âloigner">‚¨áÔ∏è</button>
                    </div>
                    <button class="reset-btn" onclick="resetLight()">Reset</button>
                    <div class="info-display" id="lightZInfo">Z:7</div>
                </div>
            </div>

            <!-- Contr√¥leur Labels X (ann√©es) -->
            <div class="controller">
                <h3>üè∑Ô∏è Labels X</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLabels_Annees('up')">‚Üë</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLabels_Annees('left')">‚Üê</button>
                        <button class="joystick-btn" onclick="moveLabels_Annees('center')">‚óè</button>
                        <button class="joystick-btn" onclick="moveLabels_Annees('right')">‚Üí</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLabels_Annees('down')">‚Üì</button>
                    </div>
                    <div class="joystick-row" style="margin-top: 10px;">
                        <button class="joystick-btn" onclick="adjustFontSizeX('down')" title="R√©duire police">üÖ∞Ô∏è‚àí</button>
                        <button class="joystick-btn" onclick="adjustFontSizeX('up')" title="Augmenter police">üÖ∞Ô∏è+</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="adjustLabelsXSpacing('down')" title="R√©duire espacement">‚ÜîÔ∏è‚àí</button>
                        <button class="joystick-btn" onclick="adjustLabelsXSpacing('up')" title="Augmenter espacement">‚ÜîÔ∏è+</button>
                    </div>
                    <button class="reset-btn" onclick="resetLabels()">Reset</button>
                    <div class="info-display" id="labelsXInfo">X:0.0 Y:0.0</div>
                    <div class="info-display" id="fontSizeXInfo" style="margin-top: 5px;">100px</div>
                    <div class="info-display" id="labelsXSpacingInfo" style="margin-top: 5px;">100%</div>
                </div>
            </div>

            <!-- Contr√¥leur Labels Y (prix) -->
            <div class="controller">
                <h3>üè∑Ô∏è Labels Y</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLabels_Prix('up')">‚Üë</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLabels_Prix('left')">‚Üê</button>
                        <button class="joystick-btn" onclick="moveLabels_Prix('center')">‚óè</button>
                        <button class="joystick-btn" onclick="moveLabels_Prix('right')">‚Üí</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLabels_Prix('down')">‚Üì</button>
                    </div>
                    <div class="joystick-row" style="margin-top: 10px;">
                        <button class="joystick-btn" onclick="adjustFontSizeY('down')" title="R√©duire police">üÖ∞Ô∏è‚àí</button>
                        <button class="joystick-btn" onclick="adjustFontSizeY('up')" title="Augmenter police">üÖ∞Ô∏è+</button>
                    </div>
                    <button class="reset-btn" onclick="resetLabels()">Reset</button>
                    <div class="info-display" id="labelsYInfo">X:0.0 Y:0.0</div>
                    <div class="info-display" id="fontSizeYInfo" style="margin-top: 5px;">128px</div>
                </div>
            </div>

            <!-- Contr√¥leur Barre Rouge (Valorisation) -->
            <div class="controller">
                <h3>üî¥ Barre Rouge</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveBarreRouge('up')">‚Üë</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveBarreRouge('left')">‚Üê</button>
                        <button class="joystick-btn" onclick="moveBarreRouge('center')">‚óè</button>
                        <button class="joystick-btn" onclick="moveBarreRouge('right')">‚Üí</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveBarreRouge('down')">‚Üì</button>
                    </div>
                    <div class="joystick-row" style="margin-top: 10px;">
                        <button class="joystick-btn" onclick="moveBarreRouge('forward')" title="Rapprocher">‚¨ÜÔ∏è</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveBarreRouge('backward')" title="√âloigner">‚¨áÔ∏è</button>
                    </div>
                    <div class="joystick-row" style="margin-top: 15px; gap: 10px;">
                        <button class="joystick-btn" onclick="adjustBarreRougeIntensity('decrease')" title="Moins lumineux">üí°-</button>
                        <button class="joystick-btn" onclick="adjustBarreRougeIntensity('increase')" title="Plus lumineux">üí°+</button>
                    </div>
                    <button class="reset-btn" onclick="resetBarreRouge()">Reset</button>
                    <div class="info-display" id="barreRougeInfo">X:0.0 Y:-7.5 Z:0.0 üí°:1.5</div>
                </div>
            </div>

            <!-- Contr√¥leur Ombre Graph -->
            <div class="controller">
                <h3>üåë Ombre Graph</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveGraphShadow('up')" title="D√©placer vers le haut">‚Üë</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveGraphShadow('left')" title="D√©placer vers la gauche">‚Üê</button>
                        <button class="joystick-btn" onclick="moveGraphShadow('center')" title="Centrer">‚óè</button>
                        <button class="joystick-btn" onclick="moveGraphShadow('right')" title="D√©placer vers la droite">‚Üí</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveGraphShadow('down')" title="D√©placer vers le bas">‚Üì</button>
                    </div>
                    <div class="joystick-row" style="margin-top: 8px; gap: 5px;">
                        <button class="joystick-btn" onclick="adjustGraphShadow('size', 'decrease')" title="R√©duire taille">üìè-</button>
                        <button class="joystick-btn" onclick="adjustGraphShadow('size', 'increase')" title="Augmenter taille">üìè+</button>
                    </div>
                    <div class="joystick-row" style="margin-top: 5px; gap: 5px;">
                        <button class="joystick-btn" onclick="adjustGraphShadow('distance', 'decrease')" title="Rapprocher">üìç-</button>
                        <button class="joystick-btn" onclick="adjustGraphShadow('distance', 'increase')" title="√âloigner">üìç+</button>
                    </div>
                    <button class="reset-btn" onclick="resetGraphShadow()">Reset</button>
                    <div class="info-display" id="graphShadowInfo">X:0 Z:0 üìè:35 üìç:-6.5</div>
                </div>
            </div>

            <!-- Contr√¥leur Ombre Barre Rouge -->
            <div class="controller">
                <h3>üåë Ombre Barre</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveBarreShadow('up')" title="D√©placer vers le haut">‚Üë</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveBarreShadow('left')" title="D√©placer vers la gauche">‚Üê</button>
                        <button class="joystick-btn" onclick="moveBarreShadow('center')" title="Centrer">‚óè</button>
                        <button class="joystick-btn" onclick="moveBarreShadow('right')" title="D√©placer vers la droite">‚Üí</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveBarreShadow('down')" title="D√©placer vers le bas">‚Üì</button>
                    </div>
                    <div class="joystick-row" style="margin-top: 8px; gap: 5px;">
                        <button class="joystick-btn" onclick="adjustBarreShadow('size', 'decrease')" title="R√©duire taille">üìè-</button>
                        <button class="joystick-btn" onclick="adjustBarreShadow('size', 'increase')" title="Augmenter taille">üìè+</button>
                    </div>
                    <div class="joystick-row" style="margin-top: 5px; gap: 5px;">
                        <button class="joystick-btn" onclick="adjustBarreShadow('distance', 'decrease')" title="Rapprocher">üìç-</button>
                        <button class="joystick-btn" onclick="adjustBarreShadow('distance', 'increase')" title="√âloigner">üìç+</button>
                    </div>
                    <button class="reset-btn" onclick="resetBarreShadow()">Reset</button>
                    <div class="info-display" id="barreShadowInfo">X:0 Z:0 üìè:15 üìç:-6.4</div>
                </div>
            </div>

            <!-- Contr√¥leur Lignes Horizontales -->
            <div class="controller">
                <h3>üìè Lignes Fond</h3>
                <div class="joystick-container">
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLinesHorizontales('up')">‚Üë</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLinesHorizontales('left')">‚Üê</button>
                        <button class="joystick-btn" onclick="moveLinesHorizontales('center')">‚óè</button>
                        <button class="joystick-btn" onclick="moveLinesHorizontales('right')">‚Üí</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLinesHorizontales('down')">‚Üì</button>
                    </div>
                    <div class="joystick-row" style="margin-top: 10px;">
                        <button class="joystick-btn" onclick="moveLinesHorizontales('forward')" title="Rapprocher">‚¨ÜÔ∏è</button>
                    </div>
                    <div class="joystick-row">
                        <button class="joystick-btn" onclick="moveLinesHorizontales('backward')" title="√âloigner">‚¨áÔ∏è</button>
                    </div>
                    <button class="reset-btn" onclick="resetLinesHorizontales()">Reset</button>
                    <div class="info-display" id="linesInfo">X:0.0 Y:0.0 Z:0.0</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ========================================
        // CONFIGURATION WEBSOCKET
        // ========================================
        const WS_URL = 'wss://ecamm-overlay-server.onrender.com';
        let ws = null;
        let reconnectTimeout = null;

        // ========================================
        // VARIABLES GLOBALES THREE.JS
        // ========================================
        let threeScene = null;
        let threeCamera = null;
        let threeRenderer = null;
        let chartCurve = null;
        let constructionProgress = 0;
        let rotationStartTime = null;
        let animationFrameId = null;
        let mockData = null;
        let valuationCube = null;
        let valuationStartTime = null;
        let chartMesh = null;  // Stocker le mesh pour l'animation
        let directionalLight = null; // R√©f√©rence √† la lumi√®re
        let yearLabelsSprites = []; // Stocker les labels ann√©es (axe X)
        let priceLabelsSprites = []; // Stocker les labels prix (axe Y)
        let horizontalLines = []; // Stocker les lignes horizontales
        let graphShadowMesh = null; // NOUVEAU : Mesh de l'ombre du graphique
        let barreShadowMesh = null; // NOUVEAU : Mesh de l'ombre de la barre rouge

        // Variables de position
        let cameraOffset = { x: 0, y: 5, z: 32 };
        let cameraAngle = { horizontal: 0, vertical: -20 }; // En degr√©s
        let graphOffset = { x: 0, y: 0 };  // OBSOL√àTE : d√©place toute la sc√®ne (gard√© pour compatibilit√©)
        let graphMeshOffset = { x: 0, y: 0, z: 0 }; // NOUVEAU : d√©place uniquement le mesh 3D du graphique
        let lightPosition = { x: 5, y: 10, z: 7 }; // Position lumi√®re
        let lightIntensity = 0.6; // Intensit√© lumi√®re
        let labelsXOffset = { x: 0, y: 0 }; // Offset SEULEMENT pour labels X (ann√©es)
        let labelsYOffset = { x: 0, y: 0 }; // Offset SEULEMENT pour labels Y (prix)
        let barreRougeOffset = { x: 0, y: -7.5, z: 0 }; // Position barre rouge (z = offset seulement)
        let barreRougeIntensity = 1.5; // Intensit√© √©missive de la barre rouge (0.0 √† 3.0)
        let barreRougeSize = { width: 9, height: 0.325 }; // Taille barre rouge
        
        // NOUVEAU : Param√®tres d'ombres
        let graphShadowSize = 35; // Taille de l'ombre du graphique (10 √† 100)
        let graphShadowDistance = -6.45; // Distance de l'ombre par rapport au graphique (-10 √† 0)
        let graphShadowPosition = { x: 0, z: 0 }; // NOUVEAU : Position X/Z de l'ombre du graphique
        let barreShadowSize = 15; // Taille de l'ombre de la barre rouge (5 √† 50)
        let barreShadowDistance = -6.4; // Distance de l'ombre par rapport √† la barre (-10 √† 0)
        let barreShadowPosition = { x: 0, z: 0 }; // NOUVEAU : Position X/Z de l'ombre de la barre
        
        let linesOffset = { x: 0, y: 0, z: 0 }; // NOUVEAU : Offset des lignes horizontales
        let fontSizeLabelsX = 100; // Taille police labels X (ann√©es)
        let fontSizeLabelsY = 128; // Taille police labels Y (prix)
        let labelsXSpacing = 1.0; // NOUVEAU : Espacement entre labels X (multiplicateur, 1.0 = normal)
        const MOVE_STEP = 0.5; // Unit√©s de d√©placement par clic (r√©duit pour plus de pr√©cision)
        const ANGLE_STEP = 1; // 1¬∞ de rotation par clic
        const LIGHT_STEP = 1; // Pas de d√©placement lumi√®re
        const INTENSITY_STEP = 0.1; // Pas d'intensit√©
        const LABEL_STEP = 0.5; // Pas de d√©placement labels
        const BARRE_STEP = 0.5; // Pas de d√©placement barre rouge
        const SIZE_STEP = 0.5; // Pas de taille barre rouge

        function moveCamera(direction) {
            const step = MOVE_STEP;
            switch(direction) {
                case 'up': cameraOffset.y += step; break;
                case 'down': cameraOffset.y -= step; break;
                case 'left': cameraOffset.x -= step; break;
                case 'right': cameraOffset.x += step; break;
                case 'center': /* ne rien faire */ break;
            }
            updateCamera();
        }

        function rotateCamera(direction) {
            const step = ANGLE_STEP;
            switch(direction) {
                case 'up': cameraAngle.vertical += step; break;
                case 'down': cameraAngle.vertical -= step; break;
                case 'left': cameraAngle.horizontal -= step; break;
                case 'right': cameraAngle.horizontal += step; break;
                case 'center': /* ne rien faire */ break;
            }
            updateCamera();
        }

        function moveGraph(direction) {
            const step = MOVE_STEP;
            switch(direction) {
                case 'up': graphMeshOffset.y += step; break;
                case 'down': graphMeshOffset.y -= step; break;
                case 'left': graphMeshOffset.x -= step; break;
                case 'right': graphMeshOffset.x += step; break;
                case 'forward': graphMeshOffset.z += step; break;  // Rapprocher
                case 'backward': graphMeshOffset.z -= step; break; // √âloigner
                case 'center': graphMeshOffset = { x: 0, y: 0, z: 0 }; break;
            }
            updateGraphPosition();
        }

        function updateCamera() {
            if (threeCamera) {
                // Position
                threeCamera.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);
                
                // Calculer le point lookAt avec les angles
                const distance = 10;
                const horizontalRad = (cameraAngle.horizontal * Math.PI) / 180;
                const verticalRad = (cameraAngle.vertical * Math.PI) / 180;
                
                // Point de vis√©e calcul√© avec les angles
                const lookX = cameraOffset.x + Math.sin(horizontalRad) * distance * Math.cos(verticalRad);
                const lookY = cameraOffset.y + Math.sin(verticalRad) * distance;
                const lookZ = -Math.cos(horizontalRad) * distance * Math.cos(verticalRad);
                
                threeCamera.lookAt(lookX, lookY, lookZ);
                
                // Mise √† jour affichage
                document.getElementById('cameraInfo').textContent = 
                    `X:${cameraOffset.x.toFixed(0)} Y:${cameraOffset.y.toFixed(0)} Z:${cameraOffset.z}`;
                
                document.getElementById('angleInfo').textContent = 
                    `H:${cameraAngle.horizontal.toFixed(0)}¬∞ V:${cameraAngle.vertical.toFixed(0)}¬∞`;
                
                // Log pour debug (uniquement toutes les 10 modifications)
                if (!window.updateCount) window.updateCount = 0;
                window.updateCount++;
                if (window.updateCount % 10 === 0) {
                    console.log('üìπ Positions actuelles:', { cameraOffset, cameraAngle, graphOffset });
                }
            }
        }

        function updateGraphPosition() {
            if (chartMesh) {
                // D√©placer UNIQUEMENT le mesh du graphique, pas toute la sc√®ne
                chartMesh.position.set(graphMeshOffset.x, graphMeshOffset.y, graphMeshOffset.z);
                document.getElementById('graphInfo').textContent = 
                    `X:${graphMeshOffset.x.toFixed(0)} Y:${graphMeshOffset.y.toFixed(0)} Z:${graphMeshOffset.z.toFixed(0)}`;
                document.getElementById('graphZInfo').textContent = 
                    `Z:${graphMeshOffset.z.toFixed(0)}`;
                console.log('üìä Graph mesh position mise √† jour:', graphMeshOffset);
            } else {
                console.log('‚ö†Ô∏è updateGraphPosition appel√© mais chartMesh n\'existe pas encore');
            }
        }

        function resetCamera() {
            cameraOffset = { x: 0, y: 5, z: 32 };
            updateCamera();
        }

        function resetCameraAngle() {
            cameraAngle = { horizontal: 0, vertical: -20 };
            updateCamera();
        }

        function resetGraph() {
            graphMeshOffset = { x: 0, y: 0, z: 0 };
            updateGraphPosition();
        }

        function moveLight(direction) {
            const step = LIGHT_STEP;
            switch(direction) {
                case 'up': lightPosition.y += step; break;
                case 'down': lightPosition.y -= step; break;
                case 'left': lightPosition.x -= step; break;
                case 'right': lightPosition.x += step; break;
                case 'forward': lightPosition.z -= step; break; // Avant (se rapproche)
                case 'backward': lightPosition.z += step; break; // Arri√®re (s'√©loigne)
                case 'center': /* ne rien faire */ break;
            }
            updateLight();
        }

        function adjustIntensity(direction) {
            if (direction === 'up') {
                lightIntensity = Math.min(2.0, lightIntensity + INTENSITY_STEP);
            } else if (direction === 'down') {
                lightIntensity = Math.max(0.0, lightIntensity - INTENSITY_STEP);
            }
            updateLight();
        }

        function updateLight() {
            if (directionalLight) {
                directionalLight.position.set(lightPosition.x, lightPosition.y, lightPosition.z);
                directionalLight.intensity = lightIntensity;
                
                document.getElementById('lightInfo').textContent = 
                    `X:${lightPosition.x.toFixed(0)} Y:${lightPosition.y.toFixed(0)} Z:${lightPosition.z}`;
                
                document.getElementById('lightZInfo').textContent = 
                    `Z:${lightPosition.z.toFixed(0)}`;
                
                document.getElementById('intensityInfo').textContent = 
                    `${(lightIntensity * 100).toFixed(0)}%`;
            }
        }

        function resetLight() {
            lightPosition = { x: 5, y: 10, z: 7 };
            lightIntensity = 0.6;
            updateLight();
        }

        function moveLabels_Annees(direction) {
            // Contr√¥le SEULEMENT les labels X (ann√©es)
            const step = LABEL_STEP;
            switch(direction) {
                case 'up': labelsXOffset.y += step; break;
                case 'down': labelsXOffset.y -= step; break;
                case 'left': labelsXOffset.x -= step; break;
                case 'right': labelsXOffset.x += step; break;
                case 'center': /* ne rien faire */ break;
            }
            updateLabels();
        }

        function moveLabels_Prix(direction) {
            // Contr√¥le SEULEMENT les labels Y (prix)
            const step = LABEL_STEP;
            switch(direction) {
                case 'up': labelsYOffset.y += step; break;
                case 'down': labelsYOffset.y -= step; break;
                case 'left': labelsYOffset.x -= step; break;
                case 'right': labelsYOffset.x += step; break;
                case 'center': /* ne rien faire */ break;
            }
            updateLabels();
        }

        function updateLabels() {
            // Mettre √† jour labels X (ann√©es) avec leur propre offset
            yearLabelsSprites.forEach(sprite => {
                sprite.position.x = sprite.userData.baseX + labelsXOffset.x;
                sprite.position.y = sprite.userData.baseY + labelsXOffset.y;
            });
            
            // Mettre √† jour labels Y (prix) avec leur propre offset
            priceLabelsSprites.forEach(sprite => {
                sprite.position.x = sprite.userData.baseX + labelsYOffset.x;
                sprite.position.y = sprite.userData.baseY + labelsYOffset.y;
            });
            
            // Mettre √† jour lignes horizontales (suivent les labels Y)
            horizontalLines.forEach(line => {
                line.position.y = line.userData.baseY + labelsYOffset.y;
            });
            
            // Affichages s√©par√©s
            document.getElementById('labelsXInfo').textContent = `X:${labelsXOffset.x.toFixed(1)} Y:${labelsXOffset.y.toFixed(1)}`;
            document.getElementById('labelsYInfo').textContent = `X:${labelsYOffset.x.toFixed(1)} Y:${labelsYOffset.y.toFixed(1)}`;
        }

        function resetLabels() {
            labelsXOffset = { x: 0, y: 0 };
            labelsYOffset = { x: 0, y: 0 };
            updateLabels();
        }

        // ========================================
        // CONTR√îLE TAILLE POLICE LABELS
        // ========================================

        function adjustFontSizeX(direction) {
            const STEP = 4; // Augmenter/diminuer de 4px
            
            if (direction === 'up') {
                fontSizeLabelsX += STEP;
            } else if (direction === 'down') {
                fontSizeLabelsX = Math.max(20, fontSizeLabelsX - STEP); // Minimum 20px
            }
            
            // Recr√©er les labels avec la nouvelle taille
            regenerateLabels();
            
            // Mettre √† jour l'affichage
            document.getElementById('fontSizeXInfo').textContent = `${fontSizeLabelsX}px`;
        }

        function adjustFontSizeY(direction) {
            const STEP = 4; // Augmenter/diminuer de 4px
            
            if (direction === 'up') {
                fontSizeLabelsY += STEP;
            } else if (direction === 'down') {
                fontSizeLabelsY = Math.max(20, fontSizeLabelsY - STEP); // Minimum 20px
            }
            
            // Recr√©er les labels avec la nouvelle taille
            regenerateLabels();
            
            // Mettre √† jour l'affichage
            document.getElementById('fontSizeYInfo').textContent = `${fontSizeLabelsY}px`;
        }

        function regenerateLabels() {
            // Supprimer tous les anciens labels
            yearLabelsSprites.forEach(sprite => threeScene.remove(sprite));
            priceLabelsSprites.forEach(sprite => threeScene.remove(sprite));
            horizontalLines.forEach(line => threeScene.remove(line));
            
            yearLabelsSprites = [];
            priceLabelsSprites = [];
            horizontalLines = [];
            
            // Recr√©er les labels avec les nouvelles tailles
            const mockData = generateMockData();
            const minValue = Math.min(...mockData.map(d => d.value));
            const maxValue = Math.max(...mockData.map(d => d.value));
            const points = mockData.map((d, i) => ({
                x: (i / (mockData.length - 1)) * 30 * labelsXSpacing - 15 * labelsXSpacing, // Multiplier par espacement
                y: ((d.value - minValue) / (maxValue - minValue)) * 14 - 7,
                z: 0
            }));
            
            addAxisLabels(mockData, points, minValue, maxValue);
            
            // IMPORTANT : R√©appliquer les offsets apr√®s r√©g√©n√©ration
            updateLabels();
        }
        
        function adjustLabelsXSpacing(direction) {
            const STEP = 0.1; // Augmenter/diminuer de 10%
            
            if (direction === 'up') {
                labelsXSpacing += STEP;
            } else if (direction === 'down') {
                labelsXSpacing = Math.max(0.1, labelsXSpacing - STEP); // Minimum 10%
            }
            
            // Recr√©er les labels avec le nouveau espacement
            regenerateLabels();
            
            // Mettre √† jour l'affichage
            document.getElementById('labelsXSpacingInfo').textContent = `${(labelsXSpacing * 100).toFixed(0)}%`;
        }

        // ========================================
        // CONTR√îLE BARRE ROUGE
        // ========================================

        function moveBarreRouge(direction) {
            const STEP = 0.5; // Pas de d√©placement
            
            switch(direction) {
                case 'up':
                    barreRougeOffset.y += STEP;
                    break;
                case 'down':
                    barreRougeOffset.y -= STEP;
                    break;
                case 'left':
                    barreRougeOffset.x -= STEP;
                    break;
                case 'right':
                    barreRougeOffset.x += STEP;
                    break;
                case 'forward':
                    barreRougeOffset.z += STEP;
                    // Pour Z, on modifie directement position.z sans passer par updateBarreRouge
                    if (valuationCube) {
                        valuationCube.position.z += STEP;
                    }
                    break;
                case 'backward':
                    barreRougeOffset.z -= STEP;
                    // Pour Z, on modifie directement position.z sans passer par updateBarreRouge
                    if (valuationCube) {
                        valuationCube.position.z -= STEP;
                    }
                    break;
                case 'center':
                    barreRougeOffset = { x: 0, y: -7.5, z: 0 };
                    break;
            }
            
            updateBarreRouge();
            
            // Mettre √† jour l'affichage
            document.getElementById('barreRougeInfo').textContent = 
                `X:${barreRougeOffset.x.toFixed(1)} Y:${barreRougeOffset.y.toFixed(1)} Z:${barreRougeOffset.z.toFixed(1)} üí°:${barreRougeIntensity.toFixed(1)}`;
        }

        function adjustBarreRougeIntensity(direction) {
            const STEP = 0.1; // Pas d'ajustement de luminosit√©
            
            if (direction === 'increase') {
                barreRougeIntensity = Math.min(3.0, barreRougeIntensity + STEP); // Max 3.0
            } else if (direction === 'decrease') {
                barreRougeIntensity = Math.max(0.3, barreRougeIntensity - STEP); // Min 0.3 (pour rester visible)
            }
            
            console.log('üí° Ajustement intensit√©:', barreRougeIntensity.toFixed(1));
            
            // NOUVELLE APPROCHE : Modifier la couleur ET l'√©missivit√© pour un effet visible
            if (valuationCube && valuationCube.material) {
                // Calculer une couleur plus claire/fonc√©e selon l'intensit√©
                const baseIntensity = barreRougeIntensity / 1.5; // Normaliser par rapport √† 1.5 (valeur de base)
                
                // Rouge de base plus sombre (204, 0, 0) ‚Üí variation selon intensit√©
                const r = Math.min(255, 204 * baseIntensity);
                const g = Math.min(80, 40 * (baseIntensity - 1)); // L√©g√®re clart√© si intensit√© > 1.5
                const b = Math.min(80, 40 * (baseIntensity - 1));
                
                // Convertir en hexad√©cimal
                const newColor = (Math.floor(r) << 16) | (Math.floor(g) << 8) | Math.floor(b);
                
                // √âmissif encore plus sombre
                const emissiveR = Math.min(204, 153 * baseIntensity);
                const emissiveColor = (Math.floor(emissiveR) << 16);
                
                valuationCube.material.color.setHex(newColor);
                valuationCube.material.emissive.setHex(emissiveColor);
                valuationCube.material.emissiveIntensity = Math.min(2.0, barreRougeIntensity);
                valuationCube.material.needsUpdate = true;
                
                console.log('‚úÖ Nouvelle couleur:', '#' + newColor.toString(16).padStart(6, '0'));
            } else {
                console.warn('‚ö†Ô∏è valuationCube ou material non disponible');
            }
            
            // Mettre √† jour l'affichage
            document.getElementById('barreRougeInfo').textContent = 
                `X:${barreRougeOffset.x.toFixed(1)} Y:${barreRougeOffset.y.toFixed(1)} Z:${barreRougeOffset.z.toFixed(1)} üí°:${barreRougeIntensity.toFixed(1)}`;
        }

        function resetBarreRouge() {
            barreRougeOffset = { x: 0, y: -7.5, z: 0 };
            barreRougeIntensity = 1.5; // Reset intensit√© aussi
            updateBarreRouge();
            // Reset Z aussi
            if (valuationCube) {
                valuationCube.position.z = 1; // Position Z initiale
                valuationCube.material.emissiveIntensity = barreRougeIntensity; // Reset intensit√©
            }
            document.getElementById('barreRougeInfo').textContent = 'X:0.0 Y:-7.5 Z:0.0 üí°:1.5';
        }

        function updateBarreRouge() {
            if (valuationCube) {
                valuationCube.position.x = barreRougeOffset.x;
                valuationCube.position.y = barreRougeOffset.y;
                console.log('üî¥ Barre rouge d√©plac√©e:', barreRougeOffset);
            }
        }

        // ========================================
        // FONCTIONS CONTR√îLE OMBRES
        // ========================================

        function moveGraphShadow(direction) {
            const STEP = 0.5;
            
            switch(direction) {
                case 'up':
                    graphShadowPosition.z -= STEP; // Z n√©gatif = vers le haut
                    break;
                case 'down':
                    graphShadowPosition.z += STEP; // Z positif = vers le bas
                    break;
                case 'left':
                    graphShadowPosition.x -= STEP;
                    break;
                case 'right':
                    graphShadowPosition.x += STEP;
                    break;
                case 'center':
                    graphShadowPosition = { x: 0, z: 0 };
                    break;
            }
            
            updateGraphShadow();
            document.getElementById('graphShadowInfo').textContent = 
                `X:${graphShadowPosition.x.toFixed(1)} Z:${graphShadowPosition.z.toFixed(1)} üìè:${graphShadowSize} üìç:${graphShadowDistance.toFixed(1)}`;
        }

        function moveBarreShadow(direction) {
            const STEP = 0.5;
            
            switch(direction) {
                case 'up':
                    barreShadowPosition.z -= STEP;
                    break;
                case 'down':
                    barreShadowPosition.z += STEP;
                    break;
                case 'left':
                    barreShadowPosition.x -= STEP;
                    break;
                case 'right':
                    barreShadowPosition.x += STEP;
                    break;
                case 'center':
                    barreShadowPosition = { x: 0, z: 0 };
                    break;
            }
            
            updateBarreShadow();
            document.getElementById('barreShadowInfo').textContent = 
                `X:${barreShadowPosition.x.toFixed(1)} Z:${barreShadowPosition.z.toFixed(1)} üìè:${barreShadowSize} üìç:${barreShadowDistance.toFixed(1)}`;
        }

        function adjustGraphShadow(type, direction) {
            const SIZE_STEP = 5;
            const DISTANCE_STEP = 0.5;
            
            if (type === 'size') {
                if (direction === 'increase') {
                    graphShadowSize = Math.min(100, graphShadowSize + SIZE_STEP);
                } else {
                    graphShadowSize = Math.max(10, graphShadowSize - SIZE_STEP);
                }
            } else if (type === 'distance') {
                if (direction === 'increase') {
                    graphShadowDistance = Math.min(0, graphShadowDistance + DISTANCE_STEP);
                } else {
                    graphShadowDistance = Math.max(-10, graphShadowDistance - DISTANCE_STEP);
                }
            }
            
            updateGraphShadow();
            document.getElementById('graphShadowInfo').textContent = 
                `X:${graphShadowPosition.x.toFixed(1)} Z:${graphShadowPosition.z.toFixed(1)} üìè:${graphShadowSize} üìç:${graphShadowDistance.toFixed(1)}`;
        }

        function adjustBarreShadow(type, direction) {
            const SIZE_STEP = 2;
            const DISTANCE_STEP = 0.5;
            
            if (type === 'size') {
                if (direction === 'increase') {
                    barreShadowSize = Math.min(50, barreShadowSize + SIZE_STEP);
                } else {
                    barreShadowSize = Math.max(5, barreShadowSize - SIZE_STEP);
                }
            } else if (type === 'distance') {
                if (direction === 'increase') {
                    barreShadowDistance = Math.min(0, barreShadowDistance + DISTANCE_STEP);
                } else {
                    barreShadowDistance = Math.max(-10, barreShadowDistance - DISTANCE_STEP);
                }
            }
            
            updateBarreShadow();
            document.getElementById('barreShadowInfo').textContent = 
                `X:${barreShadowPosition.x.toFixed(1)} Z:${barreShadowPosition.z.toFixed(1)} üìè:${barreShadowSize} üìç:${barreShadowDistance.toFixed(1)}`;
        }

        function updateGraphShadow() {
            if (graphShadowMesh) {
                graphShadowMesh.scale.set(graphShadowSize / 35, graphShadowSize / 35, 1);
                graphShadowMesh.position.x = graphShadowPosition.x;
                graphShadowMesh.position.y = graphShadowDistance;
                graphShadowMesh.position.z = graphShadowPosition.z;
            }
        }

        function updateBarreShadow() {
            if (barreShadowMesh) {
                barreShadowMesh.scale.set(barreShadowSize / 15, barreShadowSize / 15, 1);
                barreShadowMesh.position.x = barreShadowPosition.x;
                barreShadowMesh.position.y = barreShadowDistance;
                barreShadowMesh.position.z = barreShadowPosition.z;
            }
        }

        function resetGraphShadow() {
            graphShadowSize = 35;
            graphShadowDistance = -6.45;
            graphShadowPosition = { x: 0, z: 0 };
            updateGraphShadow();
            document.getElementById('graphShadowInfo').textContent = 'X:0 Z:0 üìè:35 üìç:-6.5';
        }

        function resetBarreShadow() {
            barreShadowSize = 15;
            barreShadowDistance = -6.4;
            barreShadowPosition = { x: 0, z: 0 };
            updateBarreShadow();
            document.getElementById('barreShadowInfo').textContent = 'X:0 Z:0 üìè:15 üìç:-6.4';
        }

        // ========================================
        // CONTR√îLE LIGNES HORIZONTALES
        // ========================================

        function moveLinesHorizontales(direction) {
            const STEP = 0.5; // Pas de d√©placement
            
            switch(direction) {
                case 'up':
                    linesOffset.y += STEP;
                    break;
                case 'down':
                    linesOffset.y -= STEP;
                    break;
                case 'left':
                    linesOffset.x -= STEP;
                    break;
                case 'right':
                    linesOffset.x += STEP;
                    break;
                case 'forward':
                    linesOffset.z += STEP;
                    break;
                case 'backward':
                    linesOffset.z -= STEP;
                    break;
                case 'center':
                    linesOffset = { x: 0, y: 0, z: 0 };
                    break;
            }
            
            updateLinesHorizontales();
            
            // Mettre √† jour l'affichage
            document.getElementById('linesInfo').textContent = 
                `X:${linesOffset.x.toFixed(1)} Y:${linesOffset.y.toFixed(1)} Z:${linesOffset.z.toFixed(1)}`;
        }

        function resetLinesHorizontales() {
            linesOffset = { x: 0, y: 0, z: 0 };
            updateLinesHorizontales();
            document.getElementById('linesInfo').textContent = 'X:0.0 Y:0.0 Z:0.0';
        }

        function updateLinesHorizontales() {
            horizontalLines.forEach(line => {
                const baseX = line.userData.baseX || 0;
                const baseY = line.userData.baseY;
                const baseZ = line.userData.baseZ || -5;
                line.position.set(baseX + linesOffset.x, baseY + linesOffset.y, baseZ + linesOffset.z);
            });
            console.log('üìè Lignes horizontales d√©plac√©es:', linesOffset);
        }

        // ========================================
        // SAUVEGARDE PARAM√àTRES
        // ========================================

        function applySettings() {
            // Pr√©parer les param√®tres
            const settings = {
                cameraOffset: { ...cameraOffset },
                cameraAngle: { ...cameraAngle },
                graphOffset: { ...graphOffset },  // Gard√© pour compatibilit√©
                graphMeshOffset: { ...graphMeshOffset },  // NOUVEAU
                lightPosition: { ...lightPosition },
                lightIntensity: lightIntensity,
                labelsXOffset: { ...labelsXOffset },
                labelsYOffset: { ...labelsYOffset },
                fontSizeLabelsX: fontSizeLabelsX,  // NOUVEAU : taille police X
                fontSizeLabelsY: fontSizeLabelsY,  // NOUVEAU : taille police Y
                labelsXSpacing: labelsXSpacing,    // NOUVEAU : espacement labels X
                barreRougeOffset: { ...barreRougeOffset },
                barreRougeIntensity: barreRougeIntensity, // NOUVEAU : intensit√© lumi√®re barre
                barreRougeSize: { ...barreRougeSize },
                graphShadowSize: graphShadowSize, // NOUVEAU : taille ombre graph
                graphShadowDistance: graphShadowDistance, // NOUVEAU : distance ombre graph
                graphShadowPosition: { ...graphShadowPosition }, // NOUVEAU : position X/Z ombre graph
                barreShadowSize: barreShadowSize, // NOUVEAU : taille ombre barre
                barreShadowDistance: barreShadowDistance, // NOUVEAU : distance ombre barre
                barreShadowPosition: { ...barreShadowPosition }, // NOUVEAU : position X/Z ombre barre
                linesOffset: { ...linesOffset }  // NOUVEAU
            };
            
            const btn = document.getElementById('applyButton');
            btn.textContent = '‚è≥ Sauvegarde...';
            
            try {
                // 1. Sauvegarder localement (fallback)
                localStorage.setItem('graphSettings_VORANGE', JSON.stringify(settings));
                console.log('‚úÖ Sauvegarde locale OK:', settings);
                
                // 2. Sauvegarder sur le serveur via HTTP POST
                fetch(`${WS_URL.replace('wss:', 'https:')}/api/graph`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settings)
                })
                .then(response => response.json())
                .then(data => {
                    console.log('‚úÖ Sauvegarde serveur OK:', data);
                    
                    // Animation visuelle du bouton
                    btn.classList.add('saved');
                    btn.textContent = '‚úì Synchronis√© !';
                    
                    setTimeout(() => {
                        btn.classList.remove('saved');
                        btn.textContent = '‚úì Appliquer';
                    }, 2000);
                })
                .catch(error => {
                    console.error('‚ö†Ô∏è Erreur sauvegarde serveur:', error);
                    // Fallback sur localStorage uniquement
                    btn.classList.add('saved');
                    btn.textContent = '‚úì Local seulement';
                    
                    setTimeout(() => {
                        btn.classList.remove('saved');
                        btn.textContent = '‚úì Appliquer';
                    }, 2000);
                });
                
                // 3. Broadcaster via WebSocket si connect√©
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'graph_settings',
                        settings: settings
                    }));
                    console.log('üì° Settings broadcast via WebSocket');
                }
                
            } catch(e) {
                console.error('‚ùå Erreur sauvegarde:', e);
                btn.textContent = '‚ùå Erreur';
                setTimeout(() => {
                    btn.textContent = '‚úì Appliquer';
                }, 2000);
            }
        }

        function loadSettings() {
            console.log('üì• Chargement des param√®tres...');
            
            return new Promise((resolve) => {
                // Tentative de chargement depuis le serveur
                fetch(`${WS_URL.replace('wss:', 'https:')}/api/graph`)
                    .then(response => response.json())
                    .then(settings => {
                        console.log('‚úÖ Param√®tres charg√©s depuis le serveur:', settings);
                        applyLoadedSettings(settings);
                        resolve();
                    })
                    .catch(error => {
                        console.warn('‚ö†Ô∏è Serveur non disponible, chargement localStorage:', error);
                        // Fallback sur localStorage
                        const saved = localStorage.getItem('graphSettings_VORANGE');
                        if (saved) {
                            try {
                                const settings = JSON.parse(saved);
                                console.log('‚úÖ Param√®tres charg√©s depuis localStorage:', settings);
                                applyLoadedSettings(settings);
                            } catch(e) {
                                console.log('‚ö†Ô∏è Erreur chargement localStorage:', e);
                                useDefaultSettings();
                            }
                        } else {
                            useDefaultSettings();
                        }
                        resolve();
                    });
            });
        }

        function applyLoadedSettings(settings) {
            if (settings.cameraOffset) cameraOffset = settings.cameraOffset;
            if (settings.cameraAngle) cameraAngle = settings.cameraAngle;
            if (settings.graphOffset) graphOffset = settings.graphOffset;
            if (settings.graphMeshOffset) graphMeshOffset = settings.graphMeshOffset;
            if (settings.lightPosition) lightPosition = settings.lightPosition;
            if (settings.lightIntensity !== undefined) lightIntensity = settings.lightIntensity;
            
            // Compatibilit√© v12 : si labelsOffset existe, le dupliquer
            if (settings.labelsOffset) {
                labelsXOffset = { ...settings.labelsOffset };
                labelsYOffset = { ...settings.labelsOffset };
            }
            // v13+ : charger les offsets s√©par√©s si pr√©sents
            if (settings.labelsXOffset) labelsXOffset = settings.labelsXOffset;
            if (settings.labelsYOffset) labelsYOffset = settings.labelsYOffset;
            if (settings.fontSizeLabelsX !== undefined) fontSizeLabelsX = settings.fontSizeLabelsX;  // NOUVEAU
            if (settings.fontSizeLabelsY !== undefined) fontSizeLabelsY = settings.fontSizeLabelsY;  // NOUVEAU
            if (settings.labelsXSpacing !== undefined) labelsXSpacing = settings.labelsXSpacing;    // NOUVEAU
            if (settings.barreRougeOffset) barreRougeOffset = settings.barreRougeOffset;
            if (settings.barreRougeIntensity !== undefined) barreRougeIntensity = settings.barreRougeIntensity; // NOUVEAU
            if (settings.barreRougeSize) barreRougeSize = settings.barreRougeSize;
            if (settings.graphShadowSize !== undefined) graphShadowSize = settings.graphShadowSize; // NOUVEAU
            if (settings.graphShadowDistance !== undefined) graphShadowDistance = settings.graphShadowDistance; // NOUVEAU
            if (settings.graphShadowPosition) graphShadowPosition = settings.graphShadowPosition; // NOUVEAU
            if (settings.barreShadowSize !== undefined) barreShadowSize = settings.barreShadowSize; // NOUVEAU
            if (settings.barreShadowDistance !== undefined) barreShadowDistance = settings.barreShadowDistance; // NOUVEAU
            if (settings.barreShadowPosition) barreShadowPosition = settings.barreShadowPosition; // NOUVEAU
            if (settings.linesOffset) linesOffset = settings.linesOffset;  // NOUVEAU
            
            console.log('üìπ Camera:', cameraOffset, cameraAngle);
            console.log('üìä Graph old:', graphOffset);
            console.log('üìä Graph mesh:', graphMeshOffset);
            console.log('üí° Light:', lightPosition, lightIntensity);
            console.log('üè∑Ô∏è Labels X:', labelsXOffset);
            console.log('üè∑Ô∏è Labels Y:', labelsYOffset);
            console.log('üÖ∞Ô∏è Font X:', fontSizeLabelsX);  // NOUVEAU
            console.log('üÖ∞Ô∏è Font Y:', fontSizeLabelsY);  // NOUVEAU
            console.log('üî¥ Barre:', barreRougeOffset, barreRougeSize);
            console.log('üìè Lignes:', linesOffset);
            
            // Mettre √† jour tous les affichages dans l'interface
            updateAllDisplays();
        }
        
        function updateFontSizeDisplays() {
            const fontXElement = document.getElementById('fontSizeXInfo');
            const fontYElement = document.getElementById('fontSizeYInfo');
            if (fontXElement) fontXElement.textContent = `${fontSizeLabelsX}px`;
            if (fontYElement) fontYElement.textContent = `${fontSizeLabelsY}px`;
        }
        
        function updateLabelsScale() {
            console.log('üîÑ updateLabelsScale appel√© avec:', { fontSizeLabelsX, fontSizeLabelsY });
            console.log('üìä Nombre de sprites:', { X: yearLabelsSprites.length, Y: priceLabelsSprites.length });
            
            // Mettre √† jour la scale des labels X
            const scaleFactorX = fontSizeLabelsX / 100;
            yearLabelsSprites.forEach((sprite, i) => {
                sprite.scale.set(5 * scaleFactorX, 2.5 * scaleFactorX, 1);
                if (i === 0) console.log('üè∑Ô∏è Label X[0] scale apr√®s update:', sprite.scale.x, sprite.scale.y);
            });
            
            // Mettre √† jour la scale des labels Y
            const scaleFactorY = fontSizeLabelsY / 128;
            priceLabelsSprites.forEach((sprite, i) => {
                sprite.scale.set(4.5 * scaleFactorY, 2.2 * scaleFactorY, 1);
                if (i === 0) console.log('üè∑Ô∏è Label Y[0] scale apr√®s update:', sprite.scale.x, sprite.scale.y);
            });
            
            console.log('üîÑ Scale labels mise √† jour:', { 
                X: `${(5 * scaleFactorX).toFixed(2)}√ó${(2.5 * scaleFactorX).toFixed(2)}`,
                Y: `${(4.5 * scaleFactorY).toFixed(2)}√ó${(2.2 * scaleFactorY).toFixed(2)}`
            });
        }

        function updateAllDisplays() {
            // Mettre √† jour tous les affichages de position
            const labelsXInfo = document.getElementById('labelsXInfo');
            const labelsYInfo = document.getElementById('labelsYInfo');
            const barreRougeInfo = document.getElementById('barreRougeInfo');
            const linesInfo = document.getElementById('linesInfo');
            const labelsXSpacingInfo = document.getElementById('labelsXSpacingInfo');
            const graphShadowInfo = document.getElementById('graphShadowInfo');
            const barreShadowInfo = document.getElementById('barreShadowInfo');
            
            if (labelsXInfo) labelsXInfo.textContent = `X:${labelsXOffset.x.toFixed(1)} Y:${labelsXOffset.y.toFixed(1)}`;
            if (labelsYInfo) labelsYInfo.textContent = `X:${labelsYOffset.x.toFixed(1)} Y:${labelsYOffset.y.toFixed(1)}`;
            if (barreRougeInfo) barreRougeInfo.textContent = `X:${barreRougeOffset.x.toFixed(1)} Y:${barreRougeOffset.y.toFixed(1)} Z:${barreRougeOffset.z.toFixed(1)} üí°:${barreRougeIntensity.toFixed(1)}`;
            if (linesInfo) linesInfo.textContent = `X:${linesOffset.x.toFixed(1)} Y:${linesOffset.y.toFixed(1)} Z:${linesOffset.z.toFixed(1)}`;
            if (labelsXSpacingInfo) labelsXSpacingInfo.textContent = `${(labelsXSpacing * 100).toFixed(0)}%`;
            
            // NOUVEAU : Mettre √† jour les affichages des ombres
            if (graphShadowInfo) graphShadowInfo.textContent = `X:${graphShadowPosition.x.toFixed(1)} Z:${graphShadowPosition.z.toFixed(1)} üìè:${graphShadowSize} üìç:${graphShadowDistance.toFixed(1)}`;
            if (barreShadowInfo) barreShadowInfo.textContent = `X:${barreShadowPosition.x.toFixed(1)} Z:${barreShadowPosition.z.toFixed(1)} üìè:${barreShadowSize} üìç:${barreShadowDistance.toFixed(1)}`;
            
            // Mettre √† jour les tailles de police
            updateFontSizeDisplays();
        }

        function useDefaultSettings() {
            console.log('‚ÑπÔ∏è Aucune position sauvegard√©e, utilisation des valeurs par d√©faut');
            console.log('üìπ Camera d√©faut:', cameraOffset, cameraAngle);
            console.log('üìä Graph d√©faut:', graphOffset);
            console.log('üí° Light d√©faut:', lightPosition, lightIntensity);
            console.log('üè∑Ô∏è Labels X d√©faut:', labelsXOffset);
            console.log('üè∑Ô∏è Labels Y d√©faut:', labelsYOffset);
            console.log('üî¥ Barre d√©faut:', barreRougeOffset, barreRougeSize);
        }

        function reloadAnimation() {
            console.log('üîÑ Rechargement v13...');
            
            // SAUVEGARDER les positions avant de recharger
            const savedCameraOffset = { ...cameraOffset };
            const savedCameraAngle = { ...cameraAngle };
            const savedGraphOffset = { ...graphOffset };
            const savedLightPosition = { ...lightPosition };
            const savedLightIntensity = lightIntensity;
            const savedLabelsXOffset = { ...labelsXOffset };
            const savedLabelsYOffset = { ...labelsYOffset };
            
            console.log('üíæ Positions sauvegard√©es pour reload:', {
                cameraOffset: savedCameraOffset,
                cameraAngle: savedCameraAngle,
                graphOffset: savedGraphOffset
            });
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            if (threeScene) {
                while(threeScene.children.length > 0) { 
                    threeScene.remove(threeScene.children[0]); 
                }
            }
            
            if (threeRenderer) {
                threeRenderer.dispose();
            }
            
            threeScene = null;
            threeCamera = null;
            threeRenderer = null;
            chartCurve = null;
            constructionProgress = 0;
            rotationStartTime = null;
            animationFrameId = null;
            valuationCube = null;
            valuationStartTime = null;
            chartMesh = null;
            directionalLight = null;
            yearLabelsSprites = [];
            priceLabelsSprites = [];
            horizontalLines = [];
            
            // RESTAURER les positions
            cameraOffset = savedCameraOffset;
            cameraAngle = savedCameraAngle;
            graphOffset = savedGraphOffset;
            lightPosition = savedLightPosition;
            lightIntensity = savedLightIntensity;
            labelsXOffset = savedLabelsXOffset;
            labelsYOffset = savedLabelsYOffset;
            
            console.log('üì• Positions restaur√©es:', { cameraOffset, cameraAngle, graphOffset });
            
            mockData = generateMockData();
            setTimeout(() => {
                initThreeJS();
                // Appliquer les positions APR√àS que la sc√®ne soit cr√©√©e
                setTimeout(() => {
                    updateCamera();
                    updateGraphPosition();
                    updateLight();
                    updateLabels();
                    console.log('üéØ Positions restaur√©es apr√®s reload');
                }, 150);
            }, 100);
        }

        function generateMockData() {
            // Donn√©es sur 11 ans (novembre 2015 ‚Üí novembre 2025) - 11 valeurs
            const data = [
                { label: '11/15', value: 41.08 },
                { label: '11/16', value: 42.15 },
                { label: '11/17', value: 43.50 },
                { label: '11/18', value: 44.20 },
                { label: '11/19', value: 45.80 },
                { label: '11/20', value: 46.50 },
                { label: '11/21', value: 47.90 },
                { label: '11/22', value: 49.10 },
                { label: '11/23', value: 49.85 },
                { label: '11/24', value: 50.47 },
                { label: '11/25', value: 50.87 }
            ];
            return data;
        }

        function createSmoothCurve(points) {
            // VORANGE : Courbe moins lisse pour style financier hachur√©
            const curve = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.5);
            return curve.getPoints(points.length * 3); // R√©duit de 50 √† 3 pour courbe plus anguleuse
        }

        function initThreeJS() {
            const canvas = document.getElementById('threeCanvas');
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;

            console.log('üìê Canvas:', width, 'x', height);

            threeScene = new THREE.Scene();
            threeScene.background = null;

            // Camera - Contr√¥l√©e par les offsets et angles
            threeCamera = new THREE.PerspectiveCamera(55, width / height, 0.1, 1000);
            threeCamera.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);
            
            // Calculer lookAt avec les angles
            const distance = 10;
            const horizontalRad = (cameraAngle.horizontal * Math.PI) / 180;
            const verticalRad = (cameraAngle.vertical * Math.PI) / 180;
            
            const lookX = cameraOffset.x + Math.sin(horizontalRad) * distance * Math.cos(verticalRad);
            const lookY = cameraOffset.y + Math.sin(verticalRad) * distance;
            const lookZ = -Math.cos(horizontalRad) * distance * Math.cos(verticalRad);
            
            threeCamera.lookAt(lookX, lookY, lookZ);

            // Renderer ultra HD
            threeRenderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true,
                antialias: true,
                powerPreference: 'high-performance'
            });
            threeRenderer.setSize(width, height);
            threeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 3)); // R√©duire √† 3
            // Syst√®me d'ombres d√©sactiv√© car nous utilisons des ombres personnalis√©es avec gradient radial
            threeRenderer.shadowMap.enabled = false;
            
            // IMPORTANT : Activer tone mapping pour permettre des valeurs √©missives > 1.0
            threeRenderer.toneMapping = THREE.ACESFilmicToneMapping;
            threeRenderer.toneMappingExposure = 1.0;

            // Lumi√®re
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Plus de lumi√®re ambiante
            threeScene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, lightIntensity);
            directionalLight.position.set(lightPosition.x, lightPosition.y, lightPosition.z);
            // castShadow d√©sactiv√© car nous utilisons des ombres personnalis√©es
            directionalLight.castShadow = false;
            threeScene.add(directionalLight);

            createChart3D();
            
            // NOUVEAU : Ombre "stand" style Keynote (double couche)
            // Cr√©er une texture canvas avec effet combin√© : point central + d√©grad√©
            const shadowCanvas = document.createElement('canvas');
            shadowCanvas.width = 512;
            shadowCanvas.height = 512;
            const shadowCtx = shadowCanvas.getContext('2d');
            
            // Couche 1 : Point central intense (effet stand/socle)
            const centerGradient = shadowCtx.createRadialGradient(256, 256, 0, 256, 256, 80);
            centerGradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)'); // Noir intense au centre
            centerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            shadowCtx.fillStyle = centerGradient;
            shadowCtx.fillRect(0, 0, 512, 512);
            
            // Couche 2 : Ombre port√©e plus large et douce
            const outerGradient = shadowCtx.createRadialGradient(256, 256, 80, 256, 256, 256);
            outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
            outerGradient.addColorStop(0.6, 'rgba(0, 0, 0, 0.2)');
            outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            shadowCtx.fillStyle = outerGradient;
            shadowCtx.fillRect(0, 0, 512, 512);
            
            const shadowTexture = new THREE.CanvasTexture(shadowCanvas);
            const curvedShadowGeometry = new THREE.PlaneGeometry(graphShadowSize, graphShadowSize);
            const curvedShadowMaterial = new THREE.MeshBasicMaterial({
                map: shadowTexture,
                transparent: true,
                opacity: 0.6, // Augmenter pour effet plus visible
                depthWrite: false
            });
            graphShadowMesh = new THREE.Mesh(curvedShadowGeometry, curvedShadowMaterial);
            graphShadowMesh.rotation.x = -Math.PI / 2;
            graphShadowMesh.position.set(0, graphShadowDistance, 0);
            graphShadowMesh.renderOrder = -1;
            threeScene.add(graphShadowMesh);

            animate();
        }

        function createChart3D() {
            const data = mockData;
            const rawPoints = [];

            const minValue = Math.min(...data.map(d => d.value)) - 2;
            const maxValue = Math.max(...data.map(d => d.value)) + 2;
            const range = maxValue - minValue;

            data.forEach((point, i) => {
                // √âlargir VRAIMENT : √ó 3.5 total
                const x = (i - data.length / 2) * 3.5;
                // Hauteur r√©duite : 14 pour ne pas d√©border
                const y = ((point.value - minValue) / range) * 14 - 7;
                const z = 0;
                rawPoints.push(new THREE.Vector3(x, y, z));
            });

            const smoothPoints = createSmoothCurve(rawPoints);
            chartCurve = smoothPoints;

            // D√©grad√© vertical - ORANGE/JAUNE (version originale)
            const colors = [];
            const colorBottom = new THREE.Color(0xd35400); // Orange fonc√© (211, 84, 0)
            const colorTop = new THREE.Color(0xf39c12);    // Jaune/orange clair (243, 156, 18)

            for (let i = 0; i < smoothPoints.length; i++) {
                const t = (smoothPoints[i].y + 5) / 10;
                const color = new THREE.Color().lerpColors(colorBottom, colorTop, t);
                colors.push(color.r, color.g, color.b);
            }

            // Forme 3D volum√©trique
            const shape = new THREE.Shape();
            shape.moveTo(smoothPoints[0].x, smoothPoints[0].y);
            
            for (let i = 1; i < smoothPoints.length; i++) {
                shape.lineTo(smoothPoints[i].x, smoothPoints[i].y);
            }
            
            shape.lineTo(smoothPoints[smoothPoints.length - 1].x, -7); // -7
            shape.lineTo(smoothPoints[0].x, -7);
            shape.lineTo(smoothPoints[0].x, smoothPoints[0].y);

            const extrudeSettings = {
                depth: 4,
                bevelEnabled: false
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Attribuer les couleurs correctement
            const colorAttribute = new THREE.Float32BufferAttribute([], 3);
            const positions = geometry.getAttribute('position');
            const colorsArray = [];
            
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i);
                const t = Math.max(0, Math.min(1, (y + 7) / 14)); // +7 et /14
                const color = new THREE.Color().lerpColors(colorBottom, colorTop, t);
                colorsArray.push(color.r, color.g, color.b);
            }
            
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsArray, 3));

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                metalness: 0.2,      // R√©duire metalness
                roughness: 0.6,      // Augmenter roughness
                transparent: false,   // D√©sactiver transparence
                side: THREE.FrontSide,
                flatShading: false
            });

            const mesh = new THREE.Mesh(geometry, material);
            // castShadow/receiveShadow supprim√©s car nous utilisons des ombres personnalis√©es
            
            // Animation : commencer √©cras√© (scale.y = 0.01)
            mesh.scale.y = 0.01;
            mesh.position.y = -7; // -7
            
            chartMesh = mesh;
            threeScene.add(mesh);

            addAxisLabels(data, rawPoints, minValue, maxValue);
            addValuationCube(minValue, maxValue, range);
        }

        function addAxisLabels(data, points, minValue, maxValue) {
            console.log('üè∑Ô∏è Cr√©ation labels avec fontSizeX:', fontSizeLabelsX, 'fontSizeY:', fontSizeLabelsY);
            
            // Canvas S√âPAR√â pour labels X (ann√©es)
            const canvasX = document.createElement('canvas');
            canvasX.width = 1024;
            canvasX.height = 512;
            const contextX = canvasX.getContext('2d');
            
            // Canvas S√âPAR√â pour labels Y (prix)
            const canvasY = document.createElement('canvas');
            canvasY.width = 1024;
            canvasY.height = 512;
            const contextY = canvasY.getContext('2d');
            
            // Labels X (ann√©es) - Format MM/AA
            console.log('üè∑Ô∏è Cr√©ation de', data.length, 'labels X (ann√©es)');
            data.forEach((point, i) => {
                contextX.clearRect(0, 0, 1024, 512);
                contextX.fillStyle = 'white';
                contextX.font = `bold ${fontSizeLabelsX}px Arial`;
                contextX.textAlign = 'center';
                contextX.textBaseline = 'middle';
                contextX.shadowColor = 'rgba(0, 0, 0, 1)';
                contextX.shadowBlur = 20;
                contextX.shadowOffsetX = 4;
                contextX.shadowOffsetY = 4;
                contextX.fillText(point.label, 512, 256); // Affiche "11/15", "11/16", etc.
                
                const texture = new THREE.CanvasTexture(canvasX);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                const material = new THREE.SpriteMaterial({ 
                    map: texture,
                    depthTest: false,
                    depthWrite: false
                });
                const sprite = new THREE.Sprite(material);
                
                // Scale proportionnelle √† la taille de police (base: 100px = scale 5√ó2.5)
                const scaleFactor = fontSizeLabelsX / 100;
                sprite.position.set(points[i].x, -8.5, 6);
                sprite.scale.set(5 * scaleFactor, 2.5 * scaleFactor, 1);
                sprite.renderOrder = 1000;
                
                if (i === 0) console.log(`üè∑Ô∏è Label X scale: ${(5 * scaleFactor).toFixed(2)}√ó${(2.5 * scaleFactor).toFixed(2)} (fontSizeX=${fontSizeLabelsX})`);
                
                sprite.userData = { baseX: points[i].x, baseY: -8.5 };
                yearLabelsSprites.push(sprite);
                threeScene.add(sprite);
            });

            // Labels Y (prix) - Format simple : 0, 20, 40, 60...
            const range = maxValue - minValue;
            
            // Calculer les limites du graphique (hauteur = 14 unit√©s, de -7 √† +7)
            const graphHeightUnits = 14;
            const graphYMin = -7;
            const graphYMax = 7;
            
            console.log('üè∑Ô∏è Cr√©ation de 11 labels Y (prix)');
            console.log(`   Range donn√©es: ${minValue.toFixed(1)} √† ${maxValue.toFixed(1)}`);
            console.log(`   Range graphique Y: ${graphYMin} √† ${graphYMax} (${graphHeightUnits} unit√©s)`);
            
            // Cr√©er 11 lignes espac√©es uniform√©ment sur toute la hauteur du graphique
            for (let i = 0; i <= 10; i++) {
                // Position Y dans l'espace 3D (de -7 √† +7)
                const y = graphYMin + (i / 10) * graphHeightUnits;
                
                // Prix correspondant √† cette position Y
                const price = minValue + ((y - graphYMin) / graphHeightUnits) * range;
                
                console.log(`üìä Label ${i}: Prix=${Math.round(price)}, Y=${y.toFixed(2)}`);
                
                // IMPORTANT : Cr√©er un NOUVEAU canvas pour CHAQUE label
                const canvasPrice = document.createElement('canvas');
                canvasPrice.width = 1024;
                canvasPrice.height = 512;
                const contextPrice = canvasPrice.getContext('2d');
                
                contextPrice.fillStyle = 'white';
                contextPrice.font = `bold ${fontSizeLabelsY}px Arial`;
                contextPrice.textAlign = 'right';
                contextPrice.textBaseline = 'middle';
                contextPrice.shadowColor = 'rgba(0, 0, 0, 1)';
                contextPrice.shadowBlur = 15;
                contextPrice.shadowOffsetX = 3;
                contextPrice.shadowOffsetY = 3;
                contextPrice.fillText(Math.round(price).toString(), 900, 256); // Format: "40", "60", etc.
                
                const texture = new THREE.CanvasTexture(canvasPrice);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                const material = new THREE.SpriteMaterial({ 
                    map: texture,
                    depthTest: false,  // D√âSACTIVER pour toujours afficher
                    depthWrite: false
                });
                const sprite = new THREE.Sprite(material);
                
                // Scale proportionnelle √† la taille de police (base: 128px = scale 4.5√ó2.2)
                const scaleFactor = fontSizeLabelsY / 128;
                sprite.position.set(-12, y, -3); // z=-3 pour √™tre DERRI√àRE le graph (graph est √† z=0-4)
                sprite.scale.set(4.5 * scaleFactor, 2.2 * scaleFactor, 1);
                sprite.renderOrder = 998;  // Ordre √©lev√© pour √™tre devant, mais derri√®re les labels X (999)
                
                sprite.userData = { baseX: -12, baseY: y }; // Stocker position de base
                priceLabelsSprites.push(sprite);
                threeScene.add(sprite);
                
                console.log(`‚úÖ Label ${i} ajout√©: "${Math.round(price)}" √† position Y=${y.toFixed(2)}, Z=-3`);

                // Lignes horizontales en arri√®re-plan
                const lineGeometry = new THREE.CylinderGeometry(0.064, 0.064, 40, 16); // Longueur 40
                const lineMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5,  // R√©duire opacit√© pour fond discret
                    depthTest: true,  // Respecter la profondeur
                    depthWrite: false
                });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.z = Math.PI / 2;
                line.position.set(0, y, -5);  // Z=-5 pour √™tre BIEN derri√®re le graph (Z=0-4)
                line.renderOrder = -10;  // Ordre tr√®s bas = arri√®re-plan
                line.userData = { baseX: 0, baseY: y, baseZ: -5 }; // Stocker position de base compl√®te
                horizontalLines.push(line); // Stocker pour d√©placement synchronis√©
                threeScene.add(line);
            }
            
            // Appliquer les offsets sauvegard√©s pour les lignes horizontales
            updateLinesHorizontales();
        }

        function addValuationCube(minValue, maxValue, range) {
            const ourValuation = 48.50;
            const valuationY = ((ourValuation - minValue) / (maxValue - minValue)) * 14 - 7; // 14 et -7
            
            // BARRE FINE RECTANGULAIRE : longueur r√©duite 70%, hauteur +30%
            const geometry = new THREE.BoxGeometry(9, 0.325, 8); // Largeur 9 (30√ó0.3), hauteur 0.325 (0.25√ó1.3), profondeur 8
            
            const material = new THREE.MeshStandardMaterial({
                color: 0xcc0000,       // Rouge plus sombre (204, 0, 0) au lieu de (255, 0, 0)
                metalness: 0.0,        // Totalement non m√©tallique (ne r√©fl√©chit plus la lumi√®re)
                roughness: 1.0,        // Compl√®tement mat (surface tr√®s rugueuse)
                emissive: 0x990000,    // √âmissif encore plus sombre (153, 0, 0)
                emissiveIntensity: barreRougeIntensity // Utilise la valeur sauvegard√©e ou par d√©faut (1.5)
            });
            
            valuationCube = new THREE.Mesh(geometry, material);
            valuationCube.position.set(0, valuationY - 7.5, 1); // Z=1 position initiale (m√™me profondeur que le graph)
            // castShadow supprim√© car nous utilisons des ombres personnalis√©es
            valuationCube.scale.set(1, 1, 1);
            threeScene.add(valuationCube);

            // Appliquer les offsets sauvegard√©s (si localStorage contient des valeurs)
            updateBarreRouge();

            // NOUVEAU : Ombre "stand" pour la barre rouge
            const barreShadowCanvas = document.createElement('canvas');
            barreShadowCanvas.width = 256;
            barreShadowCanvas.height = 256;
            const barreShadowCtx = barreShadowCanvas.getContext('2d');
            
            // Point central + ombre port√©e (m√™me principe que le graphique)
            const barreCenterGradient = barreShadowCtx.createRadialGradient(128, 128, 0, 128, 128, 40);
            barreCenterGradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
            barreCenterGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            barreShadowCtx.fillStyle = barreCenterGradient;
            barreShadowCtx.fillRect(0, 0, 256, 256);
            
            const barreOuterGradient = barreShadowCtx.createRadialGradient(128, 128, 40, 128, 128, 128);
            barreOuterGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
            barreOuterGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.1)');
            barreOuterGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            barreShadowCtx.fillStyle = barreOuterGradient;
            barreShadowCtx.fillRect(0, 0, 256, 256);
            
            const barreShadowTexture = new THREE.CanvasTexture(barreShadowCanvas);
            const barreShadowGeometry = new THREE.PlaneGeometry(barreShadowSize, barreShadowSize);
            const barreShadowMaterial = new THREE.MeshBasicMaterial({
                map: barreShadowTexture,
                transparent: true,
                opacity: 0.7,
                depthWrite: false
            });
            barreShadowMesh = new THREE.Mesh(barreShadowGeometry, barreShadowMaterial);
            barreShadowMesh.rotation.x = -Math.PI / 2;
            barreShadowMesh.position.set(0, barreShadowDistance, 0);
            barreShadowMesh.renderOrder = -2; // En dessous de l'ombre du graphique
            threeScene.add(barreShadowMesh);

            // Le label sera dans les stats, pas sur le graphique
            
            console.log('‚úÖ Barre valorisation ajout√©e √† Y:', valuationY - 7.5);
        }

        function updateStats(data) {
            const currentValue = data[data.length - 1].value;
            const firstValue = data[0].value;
            const variation = currentValue - firstValue;
            const highest = Math.max(...data.map(d => d.value));
            const lowest = Math.min(...data.map(d => d.value));
            const ourValuation = 48.50; // Notre valorisation

            const statsHTML = `
                <div class="stat-item">
                    <div class="stat-label">Cours</div>
                    <div class="stat-value">‚Ç¨${currentValue.toFixed(2)}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Variation</div>
                    <div class="stat-value positive">+‚Ç¨${variation.toFixed(2)}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Plus haut</div>
                    <div class="stat-value">‚Ç¨${highest.toFixed(2)}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Plus bas</div>
                    <div class="stat-value">‚Ç¨${lowest.toFixed(2)}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Notre valorisation</div>
                    <div class="stat-value" style="color: #ff4444;">‚Ç¨${ourValuation.toFixed(2)}</div>
                </div>
            `;

            document.getElementById('stats').innerHTML = statsHTML;
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            const now = Date.now();

            // Initialiser rotationStartTime d√®s le d√©but
            if (!rotationStartTime) {
                rotationStartTime = now;
            }

            const rotationElapsed = (now - rotationStartTime) / 1000;

            // Animation construction graphique (2 secondes) - Monte du bas vers le haut
            if (constructionProgress < 1) {
                constructionProgress += 0.016 / 2; // 2 secondes au lieu de 3
                constructionProgress = Math.min(1, constructionProgress);
                
                // Easing smooth (easeInOutQuad)
                const progress = constructionProgress;
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                // Animer scale.y de 0.01 √† 1
                if (chartMesh) {
                    chartMesh.scale.y = 0.01 + (eased * 0.99);
                }
            }

            // Animation cube valorisation supprim√©e - la barre reste fixe et visible

            // Rotation d√®s le d√©but (commence pendant la construction)
            const initialRotation = -0.15;
            let currentRotation;
            
            if (rotationElapsed < 2) {
                // Phase 1 : rotation initiale (2 secondes) - pendant la construction
                const t = rotationElapsed / 2;
                const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                currentRotation = eased * initialRotation;
            } else if (rotationElapsed < 15) {
                // Phase 2 : rotation continue lente (2s √† 15s)
                const continuousElapsed = rotationElapsed - 2;
                const continuousSpeed = 0.02;
                currentRotation = initialRotation + (continuousElapsed * continuousSpeed);
            } else {
                // Phase 3 : oscillation gauche-droite TR√àS LENTE (apr√®s 15s)
                const oscillationStart = rotationElapsed - 15;
                const oscillationDuration = 40; // 40 secondes pour un cycle complet (2√ó plus lent)
                const oscillationProgress = (oscillationStart % oscillationDuration) / oscillationDuration;
                
                const maxAngle = (20 * Math.PI) / 180; // 20¬∞ au lieu de 40¬∞
                const easedProgress = Math.sin(oscillationProgress * Math.PI * 2);
                
                const centerRotation = initialRotation + (13 * 0.02);
                currentRotation = centerRotation + (easedProgress * maxAngle / 2);
            }

            threeScene.rotation.y = currentRotation;

            if (threeRenderer && threeScene && threeCamera) {
                threeRenderer.render(threeScene, threeCamera);
            }
        }

        window.addEventListener('load', async () => {
            console.log('üöÄ D√©marrage v13...');
            
            // IMPORTANT : Attendre que les settings soient charg√©s AVANT d'initialiser
            await loadSettings();
            console.log('üìä Apr√®s loadSettings:', { cameraOffset, cameraAngle, graphOffset, lightPosition, labelsXOffset, labelsYOffset, fontSizeLabelsX, fontSizeLabelsY });
            
            mockData = generateMockData();
            initThreeJS();
            updateStats(mockData);
            
            // Appliquer les positions apr√®s initialisation avec d√©lai plus long
            setTimeout(() => {
                console.log('‚öôÔ∏è Application des positions...');
                if (threeCamera) {
                    updateCamera();
                    console.log('‚úÖ Cam√©ra mise √† jour');
                }
                if (threeScene) {
                    updateGraphPosition();
                    console.log('‚úÖ Graphique mis √† jour');
                }
                if (directionalLight) {
                    updateLight();
                    console.log('‚úÖ Lumi√®re mise √† jour');
                }
                if (yearLabelsSprites.length > 0 || priceLabelsSprites.length > 0) {
                    updateLabels();
                    // R√©g√©n√©rer les labels pour appliquer les tailles de police charg√©es
                    if (fontSizeLabelsX !== 100 || fontSizeLabelsY !== 128 || labelsXSpacing !== 1.0) {
                        console.log('üîÑ R√©g√©n√©ration labels car tailles/espacement diff√©rents des d√©fauts');
                        regenerateLabels();
                    }
                    console.log('‚úÖ Labels mis √† jour');
                }
                // IMPORTANT : Appliquer les positions des ombres
                if (graphShadowMesh) {
                    updateGraphShadow();
                    console.log('‚úÖ Ombre graphique mise √† jour');
                }
                if (barreShadowMesh) {
                    updateBarreShadow();
                    console.log('‚úÖ Ombre barre mise √† jour');
                }
                // Mettre √† jour les affichages des ombres
                updateAllDisplays();
                console.log('üéØ TOUTES les positions appliqu√©es');
            }, 300); // Augmenter d√©lai √† 300ms
        });

        // ========================================
        // WEBSOCKET - SYNCHRONISATION TEMPS R√âEL
        // ========================================

        function connectWebSocket() {
            console.log('üîå Connexion WebSocket...');
            
            try {
                ws = new WebSocket(WS_URL);
                
                ws.onopen = () => {
                    console.log('‚úÖ WebSocket connect√©');
                    if (reconnectTimeout) {
                        clearTimeout(reconnectTimeout);
                        reconnectTimeout = null;
                    }
                };
                
                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        console.log('üì® Message WebSocket re√ßu:', message.type);
                        
                        if (message.type === 'init' && message.graphSettings) {
                            // Charger les param√®tres √† la connexion initiale
                            console.log('üì• Param√®tres initiaux re√ßus:', message.graphSettings);
                            applyLoadedSettings(message.graphSettings);
                        }
                        
                        if (message.type === 'graph_settings') {
                            // Synchronisation des param√®tres depuis un autre client
                            console.log('üîÑ Synchronisation param√®tres depuis autre client:', message.settings);
                            applyLoadedSettings(message.settings);
                            
                            // Appliquer visuellement
                            if (threeCamera) updateCamera();
                            if (threeScene) updateGraphPosition();
                            if (directionalLight) updateLight();
                            if (yearLabelsSprites.length > 0 || priceLabelsSprites.length > 0) updateLabels();
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur parsing message WebSocket:', error);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('‚ùå Erreur WebSocket:', error);
                };
                
                ws.onclose = () => {
                    console.log('üîå WebSocket d√©connect√©');
                    ws = null;
                    
                    // Reconnexion automatique apr√®s 3 secondes
                    if (!reconnectTimeout) {
                        reconnectTimeout = setTimeout(() => {
                            console.log('üîÑ Tentative de reconnexion...');
                            connectWebSocket();
                        }, 3000);
                    }
                };
            } catch (error) {
                console.error('‚ùå Erreur cr√©ation WebSocket:', error);
            }
        }

        // D√©marrer la connexion WebSocket
        connectWebSocket();
    </script>
</body>
</html>
